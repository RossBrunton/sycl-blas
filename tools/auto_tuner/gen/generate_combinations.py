#!/usr/bin/env python

import sys
import os
import json

from itertools import product

if len(sys.argv) < 2:
    sys.stderr.write("{} config [output]\n".format(sys.argv[0]))
    sys.exit(1)

ofile = sys.stdout
if len(sys.argv) > 2:
    ofile = open(sys.argv[2], "wt")

config = json.load(open(sys.argv[1]))

LOCAL = "Local"
NON_LOCAL = "NonLocal"
NAIVE = "Naive"

def cbool(bool):
    return "true" if bool else "false"

def writeln(str):
    ofile.write(str)
    ofile.write("\n")
    ofile.flush()

def write(str):
    ofile.write(str)

def print_entry_local(cls, tile, double_buffer, nbca, nbcb):
    writeln("tune<{}, Tile<{}>, {}, {}, {}, {}>(rep, args);".format(cls,
        ", ".join(map(str, tile)), cbool(double_buffer), cbool(nbca),
        cbool(nbcb), LOCAL))

def print_entry_nonlocal(cls, tile):
    writeln("tune<{}, Tile<{}>, false, false, false, {}>(rep, args);".format(
        cls, ", ".join(map(str, tile)), NON_LOCAL))

def print_entry_naive(cls, tile):
    writeln("tune<{}, Tile<>, false, false, false, {}>(rep, args);".format(cls,
        NAIVE))

writeln("// **** FILE AUTOGENERATED BY gen/generate_combinations.py ****")
writeln("// Config from: {}".format(sys.argv[1]))
writeln("")

for r in config.get("local", []):
    for (cls, item, wg) in product(r["cache_line_size"], r["item"], r["item_level_tiles"]):
        for (tl, db, ncba, ncbb) in product(r["block_level_tiles"], r["double_buffer"], r["no_bank_conflict_a"], r["no_bank_conflict_b"]):
            print_entry_local(cls, item + wg + tl, db, ncba, ncbb)
        writeln("")

for r in config.get("non_local", []):
    for cls in r["cache_line_size"]:
        for item in r["item"]:
            for wg in r["item_level_tiles"]:
                print_entry_nonlocal(cls, item + wg)
        writeln("")

for r in config.get("naive", []):
    for cls in r["cache_line_size"]:
        print_entry_naive(cls, item + wg)
